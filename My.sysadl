Model SysADLModel;

package SysADL.types {
	value type Int { }
	value type Boolean { }
	value type String { }
	value type Void { }
	value type Real { }

	enum StatusPedido {
		EM_PRODUCAO,
		PENDENTE,
		PRONTO,
		ENTREGUE
	}

	enum TipoProduto {
		PRONTO,
		PREPARADO
	}

	datatype Cliente {
		attributes :
			id : String;
			nome : String;
			senha : Int;
			saldoContra : Real;
	}

	datatype Pulseira {
		attributes :
			id : String;
			ativo : Boolean;
			contaClienteId : Int;
	}

	datatype Pedido {
		attributes :
			id : String;
			itens : ItemPedido;
			status : StatusPedido;
			qrCode : String;
			numeroOrdem : Int;
	}

	datatype ItemPedido {
		attributes :
			quantidade : Int;
			produto : Produto;
	}

	datatype Produto {
		attributes :
			id : String;
			nome : String;
			preco : Real;
			tipo : TipoProduto;
	}

	datatype Recarga {
		attributes :
			Valor : Int;
			contaClienteId : Int;
	}
	
	datatype QRCode {
		attributes : 
			dados : String ;
	} 
	
	datatype ProdutoRetirado { 
		attributes : 
			produto : Produto ; 
			quantidade : Int ;
	} 
	
	datatype ResultadoValidacaoCliente { 
		attributes : 
			cliente : Cliente ; 
			valido : Boolean ;
	}
}

package ArenaConnectors {
	import ArenaPorts;

	connector def ConectorApiCliente {
		participants :
			~source : CadastroClienteIPT;
			~destination : CadastroClienteOPT;
		flows :
			Cliente from source to destination
	}

	connector def ConectorNotificacao {
		participants :
			~source : NotificacaoStatusIPT;
			~destination : NotificacaoStatusOPT;
		flows :
			StatusPedido from source to destination
	}

	connector def ConectorApiPedido {
		participants :
			~source : EnvioPedidoIPT;
			~destination : EnvioPedidoOPT;
		flows :
			Pedido from source to destination
	}

	connector def ConectorRecarga {
		participants :
			~destination : RecargaOPT;
			~source : RecargaIPT;
		flows :
			Recarga from source to destination
	}

	connector def ConectorPreparoPedido {
		participants :
			~source : PreparoPedidoIPT;
			~destination : PreparoPedidoOPT;
		flows :
			Pedido from source to destination
	}

	connector def ConectorPedidoConcluido {
		participants :
			~source : PedidoConcluidoIPT;
			~destination : PedidoConcluidoOPT;
		flows :
			Pedido from source to destination
	}
	
	connector def ConectorDadosQRCode { 
		participants : 
			~ source : DadosQRCodeIPT ; 
			~ destination : DadosQRCodeOPT ; 
		flows : 
			QRCode from source to destination
	} 
	
	connector def AtualizaQuantidade { 
		participants : 
			~ source : ProdutoRetiradoIPT ; 
			~ destination : ProdutoRetiradoOPT ; 
		flows : 
			ProdutoRetirado from source to destination
	} 
	
	connector def ConectorResultadoValidacaoCliente { 
		participants : 
			~ destination : ResultadoValidacaoClienteOPT ; 
			~ source : ResultadoValidacaoClienteIPT ;
		flows : ResultadoValidacaoCliente from source to destination }
	}

package ArenaComponents {
	import SysADL.types;
	import ArenaConnectors;
	import ArenaPorts;

	component def TerminalAutoatendimento {
		ports :
			pCadastro : CadastroClienteOPT;
			pResposta : CadastroClienteIPT;
			pRecarga : RecargaOPT;
	} boundary

	component def TotemCompra {
		ports :
			pPedido : EnvioPedidoOPT;
			pResposta : EnvioPedidoIPT;
	}

	component def ArenaPaySystem { } boundary

	component def AplicativoCliente {
		ports :
			pRecarga : RecargaOPT;
	}

	component def Servidor {
		ports :
			apiCadastro : CadastroClienteIPT;
			apiPedido : EnvioPedidoIPT;
			apiResposta : RespostaOPT;
			pNotificacao : NotificacaoStatusOPT;
			pRecarga : RecargaIPT;
	AtualizaQuantidade : ProdutoRetiradoIPT ; } boundary

	component def MaquinaAutomatica { ports : DadosQRCode : DadosQRCodeIPT ; AtualizaQuantidade : ProdutoRetiradoOPT ; } boundary

	component def PainelBalcaoEntrega {
		ports :
			pRecebeStatus : NotificacaoStatusIPT;
	}
	component def ComputadorBalcao {
		ports :
			pStatusPedido : PedidoConcluidoOPT;
			pPedido : PreparoPedidoIPT;
	}

	component def TelaTouchScreen { } boundary

	component def LeitorRFID { }

	component def ARCH1 {
		configuration {
			components :
				Servidor : Servidor {
					using ports :
						apiCadastro : CadastroClienteIPT;
						apiPedido : EnvioPedidoIPT;
						apiResposta : RespostaOPT;
						pNotificacao : NotificacaoStatusOPT;
						pRecarga : RecargaIPT;
				}
				PainelBalcaoEntrega : PainelBalcaoEntrega {
					using ports :
						pRecebeStatus : NotificacaoStatusIPT;
				}
			connectors :
				ConnNotificacao : ConectorNotificacao bindings pNotificacao = pRecebeStatus;
		}
	}

	activity def GerenciarCadastroClienteAC(novoCliente : Cliente) : (clienteValidado : Cliente, mensagemResposta : String) {
		body {
			actions :
				vccan : ValidarCadastroClienteAN {
					using pins :
						novoCliente : Cliente;
				}
				eccan : EnviarCadastroClienteAN {
					using pins :
						clienteValidado : ResultadoValidacaoCliente;
				}
				emen : EnviarMensagemErroAN {
					using pins :
						clienteValidado1 : ResultadoValidacaoCliente;
				}
			delegate novoCliente to novoCliente
			
			delegate clienteValidado to eccan
			delegate mensagemResposta to emen 
			
			flow from vccan to switch {
			    case true: clienteValidado
			}
		}
	}

	action def ValidarCadastroClienteAN(novoCliente : Cliente) : ResultadoValidacaoCliente {
		constraint :
			post-condition ValidarCadastroClienteEQ
		delegate novoCliente to novoCliente 
		delegate ValidarCadastroClienteAN to clienteValidado 
	}

	constraint ValidarCadastroClienteEQ(novoCliente : Cliente) : (clienteValidado : ResultadoValidacaoCliente) {
		equation = (novoCliente->nome != null) ? (novoCliente->senha != null && novoCliente->senha > 6) : false
	}
	
	executable def ValidarCadastroClienteEX(in novoCliente : Cliente) : out ResultadoValidacaoCliente {
		let valido : Boolean = false;
		
        if (novoCliente->nome != null) {
            if (novoCliente->senha != null && novoCliente->senha > 6) {
                valido = true;
            }
        }
        
        let resultado : ResultadoValidacaoCliente = new ResultadoValidacaoCliente;
		resultado->valido = valido;
		resultado->cliente = novoCliente;
        
        return resultado;
	}

	action def EnviarCadastroClienteAN(clienteValidado : ResultadoValidacaoCliente) : Cliente {
		constraint :
			post-condition EnviarCadastroClienteEQ
	delegate EnviarCadastroClienteAN to clienteValidado delegate clienteValidado to clienteValidado }
	
	constraint EnviarCadastroClienteEQ(clienteValidado : ResultadoValidacaoCliente) : (clienteValidado : Cliente) {
	}

	action def EnviarMensagemErroAN(clienteValidado : ResultadoValidacaoCliente) : String {
		constraint :
			post-condition EnviarMensagemErroEQ
	delegate clienteValidado to clienteValidado delegate EnviarMensagemErroAN to mensagemErro }

	constraint EnviarMensagemErroEQ(clienteValidado : ResultadoValidacaoCliente) : (mensagemErro : String) {
		equation = "Os dados fornecidos não são válidos."
	}
boundary
	component def LeitorQRCode { ports : DadosQRCode : DadosQRCodeOPT ; }
	component def LeitorRFID { }
	component def ImpressoraQRCode { } boundary
	component def Catraca { } }

package ArenaPorts {
	import ArenaComponents;
	import SysADL.types;

	port def NotificacaoStatusOPT {
		flow out StatusPedido
	}

	port def NotificacaoStatusIPT {
		flow in StatusPedido
	}

	port def CadastroClienteIPT {
		flow in Cliente
	}

	port def CadastroClienteOPT {
		flow out Cliente
	}

	port def EnvioPedidoOPT {
		flow out Pedido
	}

	port def EnvioPedidoIPT {
		flow in Pedido
	}

	port def RespostaOPT {
		flow out Boolean
	}

	port def RespostaIPT {
		flow in Boolean
	}

	port def RecargaIPT {
		flow in Recarga
	}

	port def RecargaOPT {
		flow out Recarga
	}

	port def PreparoPedidoIPT {
		flow in Pedido
	}

	port def PreparoPedidoOPT {
		flow out Pedido
	}

	port def PedidoConcluidoIPT {
		flow in Pedido
	}

	port def PedidoConcluidoOPT {
		flow out Pedido
	}
	
	port def DadosQRCodeIPT { 
		flow in QRCode
	} 
	
	port def DadosQRCodeOPT { 
		flow out QRCode
	} 
	
	port def ProdutoRetiradoIPT { 
		flow in ProdutoRetirado
	} 
	
	port def ProdutoRetiradoOPT { 
		flow out ProdutoRetirado
	} 
	
	port def ResultadoValidacaoClienteIPT { 
		flow in ResultadoValidacaoCliente
	} 
	
	port def ResultadoValidacaoClienteOPT { 
		flow out ResultadoValidacaoCliente
	} 
}

Requirement AcessoSistemaFR(1) {
	text = "O sistema deve permitir o acesso de clientes"
	satisfied by ArenaComponents.Servidor , ArenaComponents.TerminalAutoatendimento ;

	Requirement AcessoSiteAplicaticoFR(2) {
		text = "O site e o aplicativo devem estar sempre disponíveis para os usuários"
		satisfied by ArenaComponents.AplicativoCliente;
	}

	Requirement AcessoArenaFR(3) {
		text = "Ao entrar na arena, o cliente deve retirar uma pulseira para realizar compras no local"
	satisfied by SysADL.types.Pulseira ; }

	Requirement RecarregarCreditosFR(4) {
		text = "O sistema deve permitir a recarga de créditos através do site/aplicativo e dos terminais de autoatendimento" satisfied by ArenaComponents.ArenaPaySystem ;

		Requirement MeioPagamentoFR(4.1) {
			text = "O sistema deve permitir a recarga através de cartão de crédito/débito e pix"
		}
	}

	Requirement ComprarProdutosFR(5) {
		text = "O cliente pode realizar compras nos totens de autoatendimento" satisfied by ArenaComponents.TotemCompra , ArenaComponents.ArenaPaySystem ;

		Requirement SelecionarItensFR(5.1) {
			text = "O sistema deve permitir que o cliente selecione itens nos totens de autoatendimento"
		satisfied by ArenaComponents.TelaTouchScreen ; }

		Requirement ConfirmarCompraFR(5.2) {
			text = "O sistema deve exigir que a compra seja confirmada aproximando a pulseira no sensor" satisfied by ArenaComponents.LeitorRFID ;

			Requirement ConfirmarPagamentoFR(5.2.1) {
				text = "O cliente deve confirmar a compra digitando a senha de 4 dígitos"
			}
		}

		Requirement GerarComprovanteFR(5.3) {
			text = "O sistema deve gerar um comprovante impresso com QR Code ou/e número de ordem de pedido para cada compra"
		satisfied by ArenaComponents.ImpressoraQRCode ; }
	}

	Requirement SairArenaFR(6) {
		text = "O cliente deve passar pela catraca ao deixar a arena" satisfied by ArenaComponents.Catraca ;

		Requirement DevolverPulseiraFR(6.1) {
			text = "O sistema deve disponibilizar pontos de coleta da pulseira na saída"
		}

		Requirement EmitirAlertaPortaFR(6.2) {
			text = "O sistema deve emitir alertas nos detectores das portas caso alguém tente sair com a pulseira"
		}
	}
}

Requirement CadastroClienteFR(2.1) {
	text = "O sistema deve permitir o cadastro de clientes pelo site/aplicativo ou nos terminais de autoatendimento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement CriarSenhaFR(2.1) {
		text = "O cliente deve definir uma senha de 4 dígitos que será utilizada para confirmar as compras no local"

		Requirement AssociarSenhaPulseirasFR(2.1.1) {
			text = "A senha criada deve ser associada a todas as pulseiras vinculadas a conta do cliente"
		}
	}
}

Requirement RetirarPulseiraFR(3.1) {
	text = "Os terminais possuem pulseiras equipadas com chip RFID e número identificador disponíveis para cada cliente"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement AssociarPulseiraFR(3.2) {
	text = "O cliente deve vincular uma pulseira a sua conta aproximando-a do leitor do terminal"
	satisfied by ArenaComponents.LeitorRFID ; derive AcessoSistemaFR.AcessoArenaFR;

	Requirement AssociarOutrasPulseiraFR(3.2.1) {
		text = "O cliente pode vincular outras pulseiras a sua conta"
	}
}

Requirement AdicionarSaldoFR(2.2) {
	text = "O cliente pode adicionar saldo à sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement TransferirSaldoFR(2.3) {
	text = "O cliente pode transferir saldo de sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement DesvincularPulseiraFR(2.4) {
	text = "O cliente pode desvincular uma pulseira a qualquer momento, em caso de perca"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement MultaPulseiraFR(2.4.1) {
		text = "O cliente deve pagar uma multa"
	}

	Requirement TravarSaldoFR(2.4.2) {
		text = "O saldo do cliente fica travado enquanto ele não pagar a multa"
	}
}

Requirement SaldoCompartilhadoFR(3.3) {
	text = "O saldo do cliente pode ser usado por todas as pulseiras cadastradas"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement DefinirLimitePulseiraFR(2.5) {
	text = "O cliente pode definir um limite de saldo para cada pulseira"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement RetirarPedidoFR(5.4) {
	text = "O cliente pode retirar os pedidos"
	derive AcessoSistemaFR.ComprarProdutosFR;

	Requirement RetirarProdutoMaquinaFR(5.4.1) {
		text = "O sistema deve permitir a retirada de itens prontos em máquinas automáticas mediante leitura do QR Code"
	satisfied by ArenaComponents.MaquinaAutomatica ; }

	Requirement ExibirStatusPedidoFR(5.4.2) {
		text = "O sistema deve exibir em telas no balcão o status do pedido (em produção ou pronto) e o número correspondente, para que o cliente entregue o comprovante e receba o produto"
		satisfied by ArenaComponents.PainelBalcaoEntrega;
	}

	Requirement RetirarPedidoBalcaoFR(5.4.3) {
		text = "O sistema deve permitir a retirada de itens preparados na hora em balcões de entrega mediante apresentação do número do pedido impresso"
		satisfied by ArenaComponents.ComputadorBalcao;
	}
}

Requirement QualidadeNFR(7) {
	text = "O sistema deve atender as necessidades de Desempenho, Disponibilidade e Confiabilidade, Segurança, Confiabilidade Operacional e Manutenibilidade e  Escalabilidade"

	Requirement DesempenhoNFR(8) {
		text = "O sistema deve suportar um grande volume de transações simultâneas durante o evento"
	}

	Requirement SegurancaNFR(9) {
		text = "O sistema deve garantir a segurança dos dados do cliente"
	}

	Requirement ConfiabilidadeNFR(10) {
		text = "O sistema deve ajudar a operacionar os registros e logs"
	}

	Requirement EscalabilidadeNFR(11) {
		text = "O sistema deve permitir adicionar mais terminais, totens e máquinas de retirada sem necessidade de grandes alterações"
	}
}

Requirement DadosNFR(9.1) {
	text = "Os dados pessoais e financeiros dos clientes devem ser armazenados de forma criptografada"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComunicacaoNFR(9.2) {
	text = "A comunicação entre dispositivos (totens, pulseiras, servidores e app) deve ser feita por canais seguros"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComprasNFR(9.3) {
	text = "O sistema deve impedir compras sem autenticação dupla (pulseira + senha de 4 dígitos)"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement TentativasNFR(9.4) {
	text = "O sistema deve bloquear automaticamente a pulseira após 3 tentativas incorretas de senha"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement DisponibilidadeNFR(10.1) {
	text = "O sistema deve estar disponível durante todo o período do evento, com tolerância mínima a falhas"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement MonitoramentoNFR(10.2) {
	text = "O sistema deve monitorar em tempo real o status de totens, máquinas de retirada e terminais"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement LogsNFR(10.3) {
	text = "O sistema deve registrar os logs de todas as operações (cadastro, compras, carregamento de crédito, devolução de pulseira)"
	derive QualidadeNFR.ConfiabilidadeNFR;
}