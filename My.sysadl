Model SysADLModel;

package SysADL.types {
	value type Int { }
	value type Boolean { }
	value type String { }
	value type Void { }
	value type Real { }

	enum StatusPedido {
		EM_PRODUCAO,
		PENDENTE,
		PRONTO,
		ENTREGUE
	}

	enum TipoProduto {
		PRONTO,
		PREPARADO
	}

	datatype Cliente {
		attributes :
			id : String;
			nome : String;
			senha : Int;
			saldoContra : Real;
	}

	datatype Pulseira {
		attributes :
			id : String;
			ativo : Boolean;
			contaClienteId : Int;
	}

	datatype Pedido {
		attributes :
			id : String;
			itens : ItemPedido;
			status : StatusPedido;
			qrCode : String;
			numeroOrdem : Int;
	}

	datatype ItemPedido {
		attributes :
			quantidade : Int;
			produto : Produto;
	}

	datatype Produto {
		attributes :
			id : String;
			nome : String;
			preco : Real;
			tipo : TipoProduto;
	}

	datatype Recarga {
		attributes :
			Valor : Int;
			contaClienteId : Int;
	}
}

package ArenaConnectors {
	import ArenaPorts;

	connector def ConectorApiCliente {
		participants :
			~source : CadastroClienteOPT;
			~destination : CadastroClienteIPT;
		flows :
			Cliente from source to destination
	}

	connector def ConectorNotificacao {
		participants :
			~source : NotificacaoStatusOPT;
			~destination : NotificacaoStatusIPT;
		flows :
			StatusPedido from source to destination
	}

	connector def ConectorApiPedido {
		participants :
			~source : EnvioPedidoOPT;
			~destination : EnvioPedidoIPT;
		flows :
			Pedido from source to destination
	}

	connector def ConectorRecarga {
		participants :
			~destination : RecargaIPT;
			~newPort : RecargaOPT;
		flows :
			Recarga from newPort to destination
	}

	connector def ConectorPreparoPedido {
		participants :
			~source : PreparoPedidoOPT;
			~destination : PreparoPedidoIPT;
		flows :
			Pedido from source to destination
	}

	connector def ConectorPedidoConcluido {
		participants :
			~source : PedidoConcluidoOPT;
			~destination : PedidoConcluidoIPT;
		flows :
			Pedido from source to destination
	}
}

package ArenaComponents {
	import SysADL.types;
	import ArenaConnectors;
	import ArenaPorts;

	component def TerminalAutoatendimento {
		ports :
			pCadastro : CadastroClienteOPT;
			pResposta : CadastroClienteIPT;
			pRecarga : RecargaOPT;
	} boundary

	component def TotemCompra {
		ports :
			pPedido : EnvioPedidoOPT;
			pResposta : EnvioPedidoIPT;
	}

	component def ArenaPaySystem { } boundary

	component def AplicativoCliente {
		ports :
			pRecarga : RecargaOPT;
	}

	component def Servidor {
		ports :
			apiCadastro : CadastroClienteIPT;
			apiPedido : EnvioPedidoIPT;
			apiResposta : RespostaOPT;
			pNotificacao : NotificacaoStatusOPT;
			pRecarga : RecargaIPT;
	} boundary

	component def MaquinaAutomatica { } boundary

	component def PainelBalcaoEntrega {
		ports :
			pRecebeStatus : NotificacaoStatusIPT;
	} boundary

	component def GatewayPagamento { }

	component def newComponent { }

	component def ComputadorBalcao {
		ports :
			pStatusPedido : PedidoConcluidoOPT;
			pPedido : PreparoPedidoIPT;
	}

	component def TelaTouchScreen { } boundary

	component def Sensor { }

	component def ARCH1 {
		configuration {
			components :
				Servidor : Servidor {
					using ports :
						apiCadastro : CadastroClienteIPT;
						apiPedido : EnvioPedidoIPT;
						apiResposta : RespostaOPT;
						pNotificacao : NotificacaoStatusOPT;
						pRecarga : RecargaIPT;
				}
				PainelBalcaoEntrega : PainelBalcaoEntrega {
					using ports :
						pRecebeStatus : NotificacaoStatusIPT;
				}
			connectors :
				ConnNotificacao : ConectorNotificacao bindings pNotificacao = pRecebeStatus;
		}
	}

	activity def GerenciarCadastroClienteAC(novoCliente : Cliente) : (clienteValidado : Cliente, mensagemResposta : String) {
		body {
			actions :
				vccan : ValidarCadastroClienteAN {
					using pins :
						novoCliente : Cliente;
				}
				eccan : EnviarCadastroClienteAN {
					using pins :
						clienteEhValido : Boolean;
				}
				emran : EnviarMensagemRespostaAN {
					using pins :
						clienteEhValido : Boolean;
				}
			delegate novoCliente to vccan
			flow from vccan to eccan
			flow from vccan to emran
		delegate clienteValidado to eccan delegate mensagemResposta to emran delegate novoCliente to novoCliente }
	}

	action def ValidarCadastroClienteAN(novoCliente : Cliente) : Boolean {
		constraint :
			post-condition ValidarCadastroClienteEQ
	}

	constraint ValidarCadastroClienteEQ(novoCliente : Cliente) : (clienteEhValido : Boolean) {
		equation = (novoCliente->nome != null) ? (novoCliente->senha != null && novoCliente->senha > 6) : false
	}

	action def EnviarCadastroClienteAN(clienteEhValido : Boolean) : Cliente {
		constraint :
			post-condition EnviarCadastroClienteEQ
	}

	action def EnviarMensagemRespostaAN(clienteEhValido : Boolean) : String {
		constraint :
			post-condition EnviarMensagemRespostaEQ
	}

	constraint EnviarCadastroClienteEQ(clienteEhValido : Boolean) : (clienteValidado : Cliente) { }

	constraint EnviarMensagemRespostaEQ(clienteEhValido : Boolean) : (mensagemResposta : String) {
		equation = clienteEhValido ? "Cadastro concluído com sucesso." : "Os dados fornecidos não são válidos."
	}
}

package ArenaPorts {
	import ArenaComponents;
	import SysADL.types;

	port def NotificacaoStatusOPT {
		flow out StatusPedido
	}

	port def NotificacaoStatusIPT {
		flow in StatusPedido
	}

	port def CadastroClienteIPT {
		flow in Cliente
	}

	port def CadastroClienteOPT {
		flow out Cliente
	}

	port def EnvioPedidoOPT {
		flow out Pedido
	}

	port def EnvioPedidoIPT {
		flow in Pedido
	}

	port def RespostaOPT {
		flow out Boolean
	}

	port def RespostaIPT {
		flow in Boolean
	}

	port def RecargaIPT {
		flow in Recarga
	}

	port def RecargaOPT {
		flow out Recarga
	}

	port def PreparoPedidoIPT {
		flow in Pedido
	}

	port def PreparoPedidoOPT {
		flow out Pedido
	}

	port def PedidoConcluidoIPT {
		flow in Pedido
	}

	port def PedidoConcluidoOPT {
		flow out Pedido
	}
}

Requirement AcessoSistemaFR(1) {
	text = "O sistema deve permitir o acesso de clientes"
	satisfied by ArenaComponents.Servidor;

	Requirement AcessoSiteAplicaticoFR(2) {
		text = "O site e o aplicativo devem estar sempre disponíveis para os usuários"
		satisfied by ArenaComponents.AplicativoCliente;
	}

	Requirement AcessoArenaFR(3) {
		text = "Ao entrar na arena, o cliente deve retirar uma pulseira para realizar compras no local"
	}

	Requirement RecarregarCreditosFR(4) {
		text = "O sistema deve permitir a recarga de créditos através do site/aplicativo e dos terminais de autoatendimento"

		Requirement MeioPagamentoFR(4.1) {
			text = "O sistema deve permitir a recarga através de cartão de crédito/débito e pix"
		}
	}

	Requirement ComprarProdutosFR(5) {
		text = "O cliente pode realizar compras nos totens de autoatendimento"

		Requirement SelecionarItensFR(5.1) {
			text = "O sistema deve permitir que o cliente selecione itens nos totens de autoatendimento"
		}

		Requirement ConfirmarCompraFR(5.2) {
			text = "O sistema deve exigir que a compra seja confirmada aproximando a pulseira no sensor"

			Requirement ConfirmarPagamentoFR(5.2.1) {
				text = "O cliente deve confirmar a compra digitando a senha de 4 dígitos"
			}
		}

		Requirement GerarComprovanteFR(5.3) {
			text = "O sistema deve gerar um comprovante impresso com QR Code ou/e número de ordem de pedido para cada compra"
		}
	}

	Requirement SairArenaFR(6) {
		text = "O cliente deve passar pela catraca ao deixar a arena"

		Requirement DevolverPulseiraFR(6.1) {
			text = "O sistema deve disponibilizar pontos de coleta da pulseira na saída"
		}

		Requirement EmitirAlertaPortaFR(6.2) {
			text = "O sistema deve emitir alertas nos detectores das portas caso alguém tente sair com a pulseira"
		}
	}
}

Requirement CadastroClienteFR(2.1) {
	text = "O sistema deve permitir o cadastro de clientes pelo site/aplicativo ou nos terminais de autoatendimento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement CriarSenhaFR(2.1) {
		text = "O cliente deve definir uma senha de 4 dígitos que será utilizada para confirmar as compras no local"

		Requirement AssociarSenhaPulseirasFR(2.1.1) {
			text = "A senha criada deve ser associada a todas as pulseiras vinculadas a conta do cliente"
		}
	}
}

Requirement RetirarPulseiraFR(3.1) {
	text = "Os terminais possuem pulseiras equipadas com chip RFID e número identificador disponíveis para cada cliente"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement AssociarPulseiraFR(3.2) {
	text = "O cliente deve vincular uma pulseira a sua conta aproximando-a do leitor do terminal"
	derive AcessoSistemaFR.AcessoArenaFR;

	Requirement AssociarOutrasPulseiraFR(3.2.1) {
		text = "O cliente pode vincular outras pulseiras a sua conta"
	}
}

Requirement AdicionarSaldoFR(2.2) {
	text = "O cliente pode adicionar saldo à sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement TransferirSaldoFR(2.3) {
	text = "O cliente pode transferir saldo de sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement DesvincularPulseiraFR(2.4) {
	text = "O cliente pode desvincular uma pulseira a qualquer momento, em caso de perca"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement MultaPulseiraFR(2.4.1) {
		text = "O cliente deve pagar uma multa"
	}

	Requirement TravarSaldoFR(2.4.2) {
		text = "O saldo do cliente fica travado enquanto ele não pagar a multa"
	}
}

Requirement SaldoCompartilhadoFR(3.3) {
	text = "O saldo do cliente pode ser usado por todas as pulseiras cadastradas"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement DefinirLimitePulseiraFR(2.5) {
	text = "O cliente pode definir um limite de saldo para cada pulseira"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement RetirarPedidoFR(5.4) {
	text = "O cliente pode retirar os pedidos"
	derive AcessoSistemaFR.ComprarProdutosFR;

	Requirement RetirarProdutoMaquinaFR(5.4.1) {
		text = "O sistema deve permitir a retirada de itens prontos em máquinas automáticas mediante leitura do QR Code"
	}

	Requirement ExibirStatusPedidoFR(5.4.2) {
		text = "O sistema deve exibir em telas no balcão o status do pedido (em produção ou pronto) e o número correspondente, para que o cliente entregue o comprovante e receba o produto"
		satisfied by ArenaComponents.PainelBalcaoEntrega;
	}

	Requirement RetirarPedidoBalcaoFR(5.4.3) {
		text = "O sistema deve permitir a retirada de itens preparados na hora em balcões de entrega mediante apresentação do número do pedido impresso"
		satisfied by ArenaComponents.ComputadorBalcao;
	}
}

Requirement QualidadeNFR(7) {
	text = "O sistema deve atender as necessidades de Desempenho, Disponibilidade e Confiabilidade, Segurança, Confiabilidade Operacional e Manutenibilidade e  Escalabilidade"

	Requirement DesempenhoNFR(8) {
		text = "O sistema deve suportar um grande volume de transações simultâneas durante o evento"
	}

	Requirement SegurancaNFR(9) {
		text = "O sistema deve garantir a segurança dos dados do cliente"
	}

	Requirement ConfiabilidadeNFR(10) {
		text = "O sistema deve ajudar a operacionar os registros e logs"
	}

	Requirement EscalabilidadeNFR(11) {
		text = "O sistema deve permitir adicionar mais terminais, totens e máquinas de retirada sem necessidade de grandes alterações"
	}
}

Requirement DadosNFR(9.1) {
	text = "Os dados pessoais e financeiros dos clientes devem ser armazenados de forma criptografada"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComunicacaoNFR(9.2) {
	text = "A comunicação entre dispositivos (totens, pulseiras, servidores e app) deve ser feita por canais seguros"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComprasNFR(9.3) {
	text = "O sistema deve impedir compras sem autenticação dupla (pulseira + senha de 4 dígitos)"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement TentativasNFR(9.4) {
	text = "O sistema deve bloquear automaticamente a pulseira após 3 tentativas incorretas de senha"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement DisponibilidadeNFR(10.1) {
	text = "O sistema deve estar disponível durante todo o período do evento, com tolerância mínima a falhas"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement MonitoramentoNFR(10.2) {
	text = "O sistema deve monitorar em tempo real o status de totens, máquinas de retirada e terminais"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement LogsNFR(10.3) {
	text = "O sistema deve registrar os logs de todas as operações (cadastro, compras, carregamento de crédito, devolução de pulseira)"
	derive QualidadeNFR.ConfiabilidadeNFR;
}