Model SysADLModel;

package SysADL.types {
	value type Int { }
	value type Boolean { }
	value type String { }
	value type Void { }
	value type Real { }

	enum StatusPedido {
		EM_PRODUCAO,
		PENDENTE,
		PRONTO,
		ENTREGUE
	}

	enum TipoProduto {
		PRONTO,
		PREPARADO
	}

	datatype ClienteDT {
		attributes :
			id : String;
			nome : String;
			senha : Int;
			saldoContra : Real;
	}

	datatype PulseiraDT {
		attributes :
			id : String;
			ativo : Boolean;
			cliente : ClienteDT;
	}

	datatype PedidoDT {
		attributes :
			id : String;
			itens : ItemPedidoDT;
			status : StatusPedido;
			qrCode : String;
			numeroOrdem : Int;
	}

	datatype ItemPedidoDT {
		attributes :
			quantidade : Int;
			produto : ProdutoDT;
	}

	datatype ProdutoDT {
		attributes :
			id : String;
			nome : String;
			preco : Real;
			tipo : TipoProduto;
	}

	datatype RecargaDT {
		attributes :
			Valor : Int;
			cliente : ClienteDT;
	}
	
	datatype ClienteValidadoDT {
	    attributes :
	        cliente : ClienteDT;
	        valido : Boolean;
	}
datatype QRCodeDT { attributes : dados : String ; } datatype ProdutoRetiradoDT { attributes : produto : ProdutoDT ; quantidade : Int ; } value type DateTime { } datatype PulseiraDetectadaDT { attributes : Detectada : Boolean ; horario : DateTime ; } datatype DadosTelaDT { attributes : Dados : String ; } datatype PagamentoDT { attributes : dados : String ; cliente : ClienteDT ; } datatype RespostaPagamentoDT { attributes : pagamento : PagamentoDT ; confirmado : Boolean ; } datatype RespostaRecargaDT { attributes : recarga : RecargaDT ; confirmado : Boolean ; } datatype AtualizaSaldoDT { attributes : valor : Real ; cliente : ClienteDT ; } }

package ArenaConnectors {
	import ArenaPorts;

	connector def CnApiCliente {
		participants :
			~source : CadastroClienteOPT;
			~destination : CadastroClienteIPT;
		flows :
			ClienteDT from source to destination
	}

	connector def CnNotificacao {
		participants :
			~source : NotificacaoStatusOPT;
			~destination : NotificacaoStatusIPT;
		flows :
			StatusPedido from source to destination
	}

	connector def CnApiPedido {
		participants :
			~source : EnvioPedidoOPT;
			~destination : EnvioPedidoIPT;
		flows :
			PedidoDT from source to destination
	}

	connector def CnRecarga {
		participants :
			~destination : RecargaIPT;
			~source : RecargaOPT;
		flows :
			RecargaDT from source to destination
	}

	connector def CnPreparoPedido {
		participants :
			~source : PreparoPedidoOPT;
			~destination : PreparoPedidoIPT;
		flows :
			PedidoDT from source to destination
	}

	connector def CnPedidoConcluido {
		participants :
			~source : PedidoConcluidoOPT;
			~destination : PedidoConcluidoIPT;
		flows :
			PedidoDT from source to destination
	}
connector def CnDadosQRCode { participants : ~ source : DadosQRCodeOPT ; ~ destination : DadosQRCodeIPT ; flows : QRCodeDT from source to destination connector def newElement { } } connector def CnAtualizaQuantidade { participants : ~ source : ProdutoRetiradoOPT ; ~ destination : ProdutoRetiradoIPT ; flows : ProdutoRetiradoDT from source to destination } connector def CnPulseiraDetectada { participants : ~ source : PulseiraDetectadaOPT ; ~ destination : PulseiraDetectadaIPT ; flows : PulseiraDetectadaDT from source to destination } connector def CnImprimeQRCode { participants : ~ destination : DadosQRCodeIPT ; ~ source : DadosQRCodeOPT ; flows : QRCodeDT from source to destination } connector def CnDetectaPulseira { participants : ~ source : DetectaPulseiraOPT ; ~ destination : DetectaPulseiraIPT ; flows : PulseiraDT from source to destination } connector def CnInteracaoTela { participants : ~ source : InteracaoTela1IOPT ; ~ destination : InteracaoTela2IOPT ; flows : DadosTelaDT from source to destination DadosTelaDT from destination to source } connector def CnPagamento { participants : ~ source : RealizaPagamentoOPT ; ~ destination : RealizaPagamentoIPT ; flows : PagamentoDT from source to destination } connector def CnConfirmaPagamento { participants : ~ source : ConfirmaPagamentoOPT ; ~ destination : ConfirmaPagamentoIPT ; flows : RespostaPagamentoDT from source to destination } connector def CnConfirmaRecarga { participants : ~ source : ConfirmaRecargaOPT ; ~ destination : ConfirmaRecargaIPT ; flows : RespostaRecargaDT from source to destination } connector def CnAtualizaSaldo { participants : ~ source : AtualizaSaldoOPT ; ~ destination : AtualizaSaldoIPT ; flows : AtualizaSaldoDT from source to destination } }

package ArenaComponents {
	import SysADL.types;
	import ArenaConnectors;
	import ArenaPorts;

	 boundary

	component def TotemCompra {
		ports :
			PT_S_18 : EnvioPedidoOPT;
			
	PT_S_15 : DadosQRCodeOPT ; PT_D_14 : DetectaPulseiraIPT ; PT_D_16 : ConfirmaPagamentoIPT ; PT_S_17 : RealizaPagamentoOPT ; configuration { components :   ImpressoraQRCode : ImpressoraQRCode { using ports : PT_D_15 : DadosQRCodeIPT ; } LeitorRFID2 : LeitorRFID2 { using ports : PT_S_14 : DetectaPulseiraOPT ; } delegations :   PT_S_14 to PT_D_14 PT_D_15 to PT_S_15 } }

	component def ArenaPaySystem { ports : PT_D_6 : RecargaIPT ; PT_S_16 : ConfirmaPagamentoOPT ; PT_D_17 : RealizaPagamentoIPT ; PT_S_7 : ConfirmaRecargaOPT ; PT_S_19 : AtualizaSaldoOPT ; } boundary

	component def AplicativoCliente {
		ports :
			PT_S_13 : RecargaOPT;
	PT_D_12 : ConfirmaRecargaIPT ; }

	 boundary

	component def MaquinaAutomatica { 
		ports : 
			PT_D_1 : DadosQRCodeIPT ; 
			PT_S_2 : ProdutoRetiradoOPT ; 
			
		configuration { 
			components :  
				LeitorQRCode : LeitorQRCode { 
					using ports : 
					PT_S_1 : DadosQRCodeOPT ;
				} 
				
			delegations :  
				PT_S_1 to PT_D_1
		}
	} boundary

	component def PainelBalcaoEntrega {
		ports :
			PT_D_9 : NotificacaoStatusIPT;
	}
	component def ComputadorBalcao {
		ports :
			PT_S_11 : PedidoConcluidoOPT;
			PT_D_10 : PreparoPedidoIPT;
	}

	component def TelaTouchScreen { ports : PT_SD1_3 : InteracaoTela1IOPT ; } boundary

	component def LeitorRFID1 { ports : PT_S_4 : DetectaPulseiraOPT ; }

	component def ARCH1 {
		
	configuration { 
		components : 
			Servidor : Servidor { 
				using ports : 
					PT_D_2 : ProdutoRetiradoIPT ; 
					PT_D_5 : CadastroClienteIPT ; 
					PT_S_9 : NotificacaoStatusOPT ; 
					PT_S_10 : PreparoPedidoOPT ; 
					PT_D_11 : PedidoConcluidoIPT ; 
					PT_D_18 : EnvioPedidoIPT ; 
					PT_D_19 : AtualizaSaldoIPT ;
			} 
			
			PainelBalcaoEntrega : PainelBalcaoEntrega { 
				using ports : 
					PT_D_9 : NotificacaoStatusIPT ;
			} 
			
			ComputadorBalcao : ComputadorBalcao { 
				using ports : 
					PT_S_11 : PedidoConcluidoOPT ; 
					PT_D_10 : PreparoPedidoIPT ;
			} 
			
			MaquinaAutomatica : MaquinaAutomatica { 
				using ports : 
					PT_D_1 : DadosQRCodeIPT ; 
					PT_S_2 : ProdutoRetiradoOPT ;
			} 
			
			LeitorQRCode : LeitorQRCode { 
				using ports : 
					PT_S_1 : DadosQRCodeOPT ;
			} 
			
			ArenaPaySystem : ArenaPaySystem { 
				using ports : 
					PT_D_6 : RecargaIPT ; 
					PT_S_16 : ConfirmaPagamentoOPT ; 
					PT_D_17 : RealizaPagamentoIPT ; 
					PT_S_7 : ConfirmaRecargaOPT ; 
					PT_S_19 : AtualizaSaldoOPT ;
			} 
			
			AplicativoCliente : AplicativoCliente { 
				using ports : 
					PT_S_13 : RecargaOPT ; 
					PT_D_12 : ConfirmaRecargaIPT ;
			} 
			
			TerminalAutoatendimento : TerminalAutoatendimento { 
				using ports : 
					PT_SD2_3 : InteracaoTela2IOPT ; 
					PT_S_5 : CadastroClienteOPT ; 
					PT_S_6 : RecargaOPT ; 
					PT_D_7 : ConfirmaRecargaIPT ; 
					PT_D_4 : DetectaPulseiraIPT ;
			} 
			
			TelaTouchScreen : TelaTouchScreen { 
				using ports : 
					PT_SD1_3 : InteracaoTela1IOPT ;
			} 
			
			LeitorRFID1 : LeitorRFID1 { 
				using ports : 
					PT_S_4 : DetectaPulseiraOPT ;
			} 
			
			TotemCompra : TotemCompra { 
				using ports : 
					PT_S_18 : EnvioPedidoOPT ; 
					PT_S_15 : DadosQRCodeOPT ; 
					PT_D_14 : DetectaPulseiraIPT ; 
					PT_D_16 : ConfirmaPagamentoIPT ; 
					PT_S_17 : RealizaPagamentoOPT ;
			} 
			
			ImpressoraQRCode : ImpressoraQRCode { 
				using ports : 
					PT_D_15 : DadosQRCodeIPT ;
			} 
			
			LeitorRFID2 : LeitorRFID2 { 
				using ports : 
					PT_S_14 : DetectaPulseiraOPT ;
			} 
			
			Catraca : Catraca { 
				using ports : 
					PT_D_8 : PulseiraDetectadaIPT ;
			} 
			
			Detector : Detector { 
				using ports : 
					PT_S_8 : PulseiraDetectadaOPT ;
			} 
			
			connectors : 
				Cn1 : CnNotificacao bindings PT_S_9 = PT_D_9 ; 
				Cn2 : CnPreparoPedido bindings PT_S_10 = PT_D_10 ; 
				Cn3 : CnPedidoConcluido bindings PT_S_11 = PT_D_11 ; 
				Cn4 : CnDadosQRCode bindings PT_S_1 = PT_D_1 ; 
				Cn5 : CnAtualizaQuantidade bindings PT_S_2 = PT_D_2 ; 
				Cn6 : CnAtualizaSaldo bindings PT_S_19 = PT_D_19 ; 
				Cn7 : CnConfirmaRecarga bindings PT_S_7 = PT_D_12 ; 
				Cn8 : CnRecarga bindings PT_S_13 = PT_D_6 ; 
				Cn9 : CnConfirmaRecarga bindings PT_S_7 = PT_D_7 ; 
				Cn10 : CnRecarga bindings PT_S_6 = PT_D_6 ; 
				Cn11 : CnApiCliente bindings PT_S_5 = PT_D_5 ; 
				Cn12 : CnInteracaoTela bindings PT_SD1_3 = PT_SD2_3 ; 
				Cn13 : CnDetectaPulseira bindings PT_S_4 = PT_D_4 ; 
				Cn14 : CnApiPedido bindings PT_S_18 = PT_D_18 ; 
				Cn15 : CnPagamento bindings PT_S_17 = PT_D_17 ; 
				Cn16 : CnConfirmaPagamento bindings PT_S_16 = PT_D_16 ; 
				Cn17 : CnDadosQRCode bindings PT_S_15 = PT_D_15 ; 
				Cn18 : CnDetectaPulseira bindings PT_S_14 = PT_D_14 ; 
				Cn19 : CnPulseiraDetectada bindings PT_S_8 = PT_D_8 ;
		} 
	}

	component def LeitorQRCode { 
		ports : PT_S_1 : DadosQRCodeOPT ;
	}
	
	component def LeitorRFID2 { 
		ports : PT_S_14 : DetectaPulseiraOPT ;
	} boundary
	
	component def ImpressoraQRCode { 
		ports : PT_D_15 : DadosQRCodeIPT ;
	} boundary
	
	component def Catraca { 
		ports : PT_D_8 : PulseiraDetectadaIPT ; 
		
		configuration { 
			components :  
				Detector : Detector { 
					using ports : 
						PT_S_8 : PulseiraDetectadaOPT ;
				} 
			delegations :  PT_S_8 to PT_D_8
		}
	} boundary
	
	component def Detector { 
		ports : PT_S_8 : PulseiraDetectadaOPT ;
	} 
	
	component def TerminalAutoatendimento { 
		ports : 
			PT_SD2_3 : InteracaoTela2IOPT ; 
			PT_S_5 : CadastroClienteOPT ; 
			PT_S_6 : RecargaOPT ; 
			PT_D_7 : ConfirmaRecargaIPT ; 
			PT_D_4 : DetectaPulseiraIPT ; 
			
		configuration { 
			components : 
				TelaTouchScreen : TelaTouchScreen { 
					using ports : 
						PT_SD1_3 : InteracaoTela1IOPT ;
				} 
				
				LeitorRFID1 : LeitorRFID1 { 
					using ports : 
						PT_S_4 : DetectaPulseiraOPT ;
				} 
				
				delegations : 
					PT_SD1_3 to PT_SD2_3 
					PT_S_4 to PT_D_4
		}
	}
	
	component def Servidor { 
		ports : 
			PT_D_2 : ProdutoRetiradoIPT ; 
			PT_D_5 : CadastroClienteIPT ; 
			PT_S_9 : NotificacaoStatusOPT ; 
			PT_S_10 : PreparoPedidoOPT ; 
			PT_D_11 : PedidoConcluidoIPT ; 
			PT_D_18 : EnvioPedidoIPT ; 
			PT_D_19 : AtualizaSaldoIPT ; 
			
		configuration { 
			components : ArenaPaySystem : ArenaPaySystem { 
				using ports : 
					PT_D_6 : RecargaIPT ; 
					PT_S_16 : ConfirmaPagamentoOPT ; 
					PT_D_17 : RealizaPagamentoIPT ; 
					PT_S_7 : ConfirmaRecargaOPT ; 
					PT_S_19 : AtualizaSaldoOPT ;
			} 
			
			delegations : 
				PT_S_19 to PT_D_19
		}
	} 

	activity def GerenciarCadastroClienteAC(novoCliente : ClienteDT) : (clienteValidado : ClienteDT, mensagemResposta : String) {
		body {
			actions :
				vccan : ValidarCadastroClienteAN {
					using pins :
						novoCliente : ClienteDT;
				}
				eccan : EnviarCadastroClienteAN {
					using pins :
						clienteValidado : ClienteValidadoDT ;
				}
				emen : EnviarMensagemErroAN {
					using pins :
						clienteValidado1 : ClienteValidadoDT ;
				}
			delegate novoCliente to novoCliente
			
			delegate clienteValidado to eccan
			delegate mensagemResposta to emen 
			
			
		flow from  vccan to clienteValidado flow from vccan to clienteValidado1 }
	}

	action def ValidarCadastroClienteAN(novoCliente : ClienteDT) : ClienteValidadoDT  {
		constraint :
			post-condition ValidarCadastroClienteEQ
		delegate novoCliente to novoCliente 
		delegate ValidarCadastroClienteAN to clienteValidado 
	}

	constraint ValidarCadastroClienteEQ(novoCliente : ClienteDT) : (clienteValidado : ClienteValidadoDT ) {
		equation = (novoCliente->nome != null) ? (novoCliente->senha != null && novoCliente->senha > 6) : false
	}
	
	executable def ValidarCadastroClienteEX(in novoCliente : ClienteDT) : out ClienteValidadoDT  {
		let valido : Boolean = false;
		
        if (novoCliente->nome != null) {
            if (novoCliente->senha != null && novoCliente->senha > 6) {
                valido = true;
            }
        }
        
        let resultado : ClienteValidadoDT  = new ClienteValidadoDT ;
		resultado->valido = valido;
		resultado->cliente = novoCliente;
        
        return resultado;
	}

	action def EnviarCadastroClienteAN(cliente : ClienteValidadoDT ) : ClienteDT {
		constraint :
			post-condition EnviarCadastroClienteEQ
	 	delegate cliente to cliente 
	 	delegate EnviarCadastroClienteAN to clienteValidado
	 }
	
	constraint EnviarCadastroClienteEQ(cliente : ClienteValidadoDT ) : (clienteValidado : ClienteDT) {
	}
	
	executable def EnviarCadastroClienteEX(in dadosValidados : ClienteValidadoDT) : out ClienteDT {
		let clienteFinal : ClienteDT = dadosValidados->cliente;
		
		return clienteFinal;
	}

	action def EnviarMensagemErroAN(clienteValidado : ClienteValidadoDT ) : String {
		constraint :
			post-condition EnviarMensagemErroEQ
	delegate clienteValidado to clienteValidado delegate EnviarMensagemErroAN to mensagemErro }

	constraint EnviarMensagemErroEQ(clienteValidado : ClienteValidadoDT ) : (mensagemErro : String) {
		equation = "Os dados fornecidos não são válidos."
	}
	
	executable def EnviarMensagemErroEX(in dadosInvalidos : ClienteValidadoDT) : out String {
		let mensagem : String = "Os dados fornecidos não são válidos.";
		
		return mensagem;
	}
	
	activity def VincularPulseiraAC ( clienteAVincular : ClienteDT ) : ( pulseiraAssociada : Boolean ) { 
		body { 
			actions : 
				ler : LerPulseiraAN { 
					using pins : 
						solicitante : ClienteDT ;
				} 
				
				associar : AssociarPulseiraAN { 
					using pins : 
						cliente : ClienteDT ; 
						pulseira : PulseiraDT ;
				} 
				
			delegate clienteAVincular to solicitante 
			delegate clienteAVincular to cliente
			delegate pulseiraAssociada to associar 
			
			flow from ler to pulseira 
			
			delegate clienteAVincular to cliente
		}
	} 
	
	action def LerPulseiraAN (  solicitante : ClienteDT ) : PulseiraDT { 
		constraint : 
			post-condition LerPulseiraEQ
	delegate LerPulseiraAN to pulseiraLida delegate solicitante to solicitante } 
	
	constraint LerPulseiraEQ ( solicitante : ClienteDT ) : ( pulseiraLida : PulseiraDT) {
		equation = pulseiraLida->id != null
	} 
	
	executable def LerPulseiraEX(in solicitante : ClienteDT) : out PulseiraDT {
		// Criamos uma nova instância de pulseira para simular o que o leitor capturou
		let novaPulseira : PulseiraDT = new PulseiraDT;
		
		// Definimos dados fictícios para simulação
		novaPulseira->id = "PULSEIRA-12345";
		novaPulseira->ativo = false;
		novaPulseira->cliente = null; 
		
		return novaPulseira;
	}
	
	action def AssociarPulseiraAN ( cliente : ClienteDT , pulseira : PulseiraDT ) : Boolean { 
		constraint : 
		post-condition AssociarPulseiraEQ
	delegate pulseira to pulseira delegate cliente to cliente delegate AssociarPulseiraAN to associadoComSucesso } 
	
	constraint AssociarPulseiraEQ ( cliente : ClienteDT , pulseira : PulseiraDT ) : ( associadoComSucesso : Boolean ) {
		equation = (pulseira->ativo == false)
	}
	
	executable def AssociarPulseiraEX(in cliente : ClienteDT, in pulseira : PulseiraDT) : out Boolean {
		let resultadoOperacao : Boolean = false;
		
		if (pulseira->ativo == false) {
			pulseira->ativo = true;
			pulseira->cliente = cliente;
			
			resultadoOperacao = true;
		}
		
		return resultadoOperacao;
	}
	
	activity def RealizarCompraAC ( pulseira : PulseiraDT ) ( senhaDigitada : Int ) ( valorTotal : Real ) : ( pedidoGerado : PedidoDT , compraSucesso : Boolean ) { 
		body { 
			actions : 
				validar : ValidarCompraAN { 
					using pins : 
						pulseira : PulseiraDT ; 
						senha : Int ; 
						valor : Real ;
				}
		
				processar : ProcessarPedidoAN { 
					using pins : 
						autorizado : Boolean ; 
						valorIn : Real ;
				} 
				
			delegate senhaDigitada to senha 
			delegate valorTotal to valor 
			delegate pulseira to pulseira 
			delegate pedidoGerado to processar 
			delegate compraSucesso to validar 
			flow from validar to autorizado 
		delegate valorTotal to valorIn }
	} 
	
	action def ValidarCompraAN ( pulseira : PulseiraDT , senha : Int , valor : Real ) : Boolean { 
		constraint : 
			post-condition ValidarCompraEQ
	delegate pulseira to pulseira delegate senha to senha delegate valor to valor delegate ValidarCompraAN to autorizado } 
	
	constraint ValidarCompraEQ ( pulseira : PulseiraDT , senha : Int , valor : Real ) : ( autorizado : Boolean ) { 
		equation = "A senha informada deve ser idêntica à senha cadastrada do cliente e o saldo disponível na conta deve ser maior ou igual ao valor total da compra."
	}
	
	executable def ValidarCompraEX (in pulseira : PulseiraDT, in senha : Int, in valor : Real) : out Boolean {
		return true;
	}
	
	action def ProcessarPedidoAN ( autorizado : Boolean , valor : Real ) : PedidoDT { 
		constraint : 
			post-condition ProcessarPedidoEQ
	delegate autorizado to autorizado delegate valor to valor delegate ProcessarPedidoAN to pedido } 
	
	constraint ProcessarPedidoEQ ( autorizado : Boolean , valor : Real ) : ( pedido : PedidoDT ) {
		equation = (autorizado == true) ? (pedido->qrCode != null) : (pedido == null)
	}
	
	executable def ProcessarPedidoEX(in autorizado : Boolean, in valor : Real) : out PedidoDT {
		let res : PedidoDT = null;
		return res;
	}

	activity def ProcessarRecargaAC(cliente : ClienteDT ) ( valorRecarga : Real) : (saldoAtualizado : Real, sucesso : Boolean) {
		body {
			actions :
				validarPag : ValidarPagamentoRecargaAN {
					using pins :
						valor : Real;
				}
				atualizar : AtualizarSaldoAN {
					using pins :
						clienteIn : ClienteDT;
						valorAdicional : Real;
						validado : Boolean;
				}
			
			delegate valorRecarga to valor
			delegate cliente to clienteIn
			delegate valorRecarga to valorAdicional
			
			flow from validarPag to validado
			
      delegate saldoAtualizado to atualizar
      delegate sucesso to validarPag
		}
	}

	action def ValidarPagamentoRecargaAN(valor : Real) : Boolean {
		constraint : post-condition ValidarPagamentoEQ
		delegate valor to valor
	}

	constraint ValidarPagamentoEQ(valor : Real) : (pagamentoConfirmado : Boolean) {
		equation = (valor > 0)
	}

	action def AtualizarSaldoAN(clienteIn : ClienteDT, valorAdicional : Real, validado : Boolean) : Real {
		constraint : post-condition AtualizarSaldoEQ
		delegate clienteIn to clienteIn
		delegate valorAdicional to valorAdicional
		delegate validado to validado
	}

	constraint AtualizarSaldoEQ(clienteIn : ClienteDT, valorAdicional : Real, validado : Boolean) : (novoSaldo : Real) {
		equation = (validado == true) ? (clienteIn->saldoContra + valorAdicional) : clienteIn->saldoContra
	}

activity def RetirarProdutoAC(qrCodeLido : String) : (portaDestravada : Boolean) {body { actions : verificar : VerificarPedidoProntoAN { using pins : codigo : String; } liberar : LiberarMecanismoAN { using pins : pedidoValido : Boolean; } delegate qrCodeLido to codigo flow from verificar to pedidoValido delegate portaDestravada to liberar } } constraint VerificarPedidoEQ ( ) { equation = (codigo != null) } constraint LiberarMecanismoEQ ( ) { equation = (pedidoValido == true) } action def VerificarPedidoProntoAN ( codigo : String ) : Boolean {   constraint : post-condition VerificarPedidoEQ
  delegate codigo to codigo } action def LiberarMecanismoAN ( pedidoValido : Boolean ) : Boolean { constraint : post-condition LiberarMecanismoEQ
  delegate pedidoValido to pedidoValido } 

activity def ControlarSaidaAC(dadosSensor : PulseiraDetectadaDT) : (catracaLiberada : Boolean, alarmeAtivado : Boolean) {
	body {
		actions :
			analisar : AnalisarRiscoSaidaAN {
				using pins :
					sinalSensor : PulseiraDetectadaDT;
			}
			
			atuar : AtuarMecanismoSaidaAN {
				using pins :
					riscoDetectado : Boolean;
			}

		delegate dadosSensor to sinalSensor
		
		flow from analisar to riscoDetectado
		
		delegate catracaLiberada to atuar
		delegate alarmeAtivado to atuar
	}
}

action def AnalisarRiscoSaidaAN ( sinalSensor : PulseiraDetectadaDT ) : Boolean { 		constraint : post-condition AnalisarRiscoEQ delegate sinalSensor to sinalSensor delegate sinalSensor to sinalSensor delegate AnalisarRiscoSaidaAN to risco } action def AtuarMecanismoSaidaAN ( riscoDetectado : Boolean ) : Boolean { constraint : post-condition AtuarMecanismoEQ delegate riscoDetectado to riscoDetectado delegate AtuarMecanismoSaidaAN to liberado delegate AtuarMecanismoSaidaAN to alarme } constraint AnalisarRiscoEQ (sinalSensor : PulseiraDetectadaDT) : (risco : Boolean) { equation = (sinalSensor->Detectada == true) } constraint AtuarMecanismoEQ (riscoDetectado : Boolean) : (liberado : Boolean, alarme : Boolean) { equation = riscoDetectado ? (false ) : (true ) } }

package ArenaPorts {
	import SysADL.types;
	port def NotificacaoStatusOPT {
		flow out StatusPedido
	}

	port def NotificacaoStatusIPT {
		flow in StatusPedido
	}

	port def CadastroClienteIPT {
		flow in ClienteDT
	}

	port def CadastroClienteOPT {
		flow out ClienteDT
	}

	port def EnvioPedidoOPT {
		flow out PedidoDT
	}

	port def EnvioPedidoIPT {
		flow in PedidoDT
	}

	

	

	port def RecargaIPT {
		flow in RecargaDT
	}

	port def RecargaOPT {
		flow out RecargaDT
	}

	port def PreparoPedidoIPT {
		flow in PedidoDT
	}

	port def PreparoPedidoOPT {
		flow out PedidoDT
	}

	port def PedidoConcluidoIPT {
		flow in PedidoDT
	}

	port def PedidoConcluidoOPT {
		flow out PedidoDT
	}
port def DadosQRCodeIPT { flow in QRCodeDT } port def DadosQRCodeOPT { flow out QRCodeDT } port def ProdutoRetiradoIPT { flow in ProdutoRetiradoDT } port def ProdutoRetiradoOPT { flow out ProdutoRetiradoDT } port def PulseiraDetectadaIPT { flow in PulseiraDetectadaDT } port def PulseiraDetectadaOPT { flow out PulseiraDetectadaDT } port def DetectaPulseiraOPT { flow out PulseiraDT } port def DetectaPulseiraIPT { flow in PulseiraDT } port def InteracaoTela1IOPT { flow inout DadosTelaDT } port def InteracaoTela2IOPT { flow inout DadosTelaDT } port def RealizaPagamentoOPT { flow out PagamentoDT } port def RealizaPagamentoIPT { flow in PagamentoDT } port def ConfirmaPagamentoOPT { flow out RespostaPagamentoDT } port def ConfirmaPagamentoIPT { flow in RespostaPagamentoDT } port def ConfirmaRecargaOPT { flow out RespostaRecargaDT } port def ConfirmaRecargaIPT { flow in RespostaRecargaDT } port def AtualizaSaldoOPT { flow out AtualizaSaldoDT } port def AtualizaSaldoIPT { flow in AtualizaSaldoDT } }

Requirement AcessoSistemaFR(1) {
	text = "O sistema deve permitir o acesso de clientes"
	Requirement AcessoSiteAplicaticoFR(2) {
		text = "O site e o aplicativo devem estar sempre disponíveis para os usuários"
		satisfied by ArenaComponents.AplicativoCliente;
	}

	Requirement AcessoArenaFR(3) {
		text = "Ao entrar na arena, o cliente deve retirar uma pulseira para realizar compras no local"
	satisfied by SysADL.types.PulseiraDT ; }

	Requirement RecarregarCreditosFR(4) {
		text = "O sistema deve permitir a recarga de créditos através do site/aplicativo e dos terminais de autoatendimento" satisfied by ArenaComponents.ArenaPaySystem ;

		Requirement MeioPagamentoFR(4.1) {
			text = "O sistema deve permitir a recarga através de cartão de crédito/débito e pix"
		}
	}

	Requirement ComprarProdutosFR(5) {
		text = "O cliente pode realizar compras nos totens de autoatendimento" satisfied by ArenaComponents.TotemCompra , ArenaComponents.ArenaPaySystem ;

		Requirement SelecionarItensFR(5.1) {
			text = "O sistema deve permitir que o cliente selecione itens nos totens de autoatendimento"
		satisfied by ArenaComponents.TelaTouchScreen ; }

		Requirement ConfirmarCompraFR(5.2) {
			text = "O sistema deve exigir que a compra seja confirmada aproximando a pulseira no sensor" satisfied by ArenaComponents.LeitorRFID1 ;

			Requirement ConfirmarPagamentoFR(5.2.1) {
				text = "O cliente deve confirmar a compra digitando a senha de 4 dígitos"
			}
		}

		Requirement GerarComprovanteFR(5.3) {
			text = "O sistema deve gerar um comprovante impresso com QR Code ou/e número de ordem de pedido para cada compra"
		satisfied by ArenaComponents.ImpressoraQRCode ; }
	}

	Requirement SairArenaFR(6) {
		text = "O cliente deve passar pela catraca ao deixar a arena" satisfied by ArenaComponents.Catraca ;

		Requirement DevolverPulseiraFR(6.1) {
			text = "O sistema deve disponibilizar pontos de coleta da pulseira na saída"
		}

		Requirement EmitirAlertaPortaFR(6.2) {
			text = "O sistema deve emitir alertas nos detectores das portas caso alguém tente sair com a pulseira"
		}
	}
}

Requirement CadastroClienteFR(2.1) {
	text = "O sistema deve permitir o cadastro de clientes pelo site/aplicativo ou nos terminais de autoatendimento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement CriarSenhaFR(2.1) {
		text = "O cliente deve definir uma senha de 4 dígitos que será utilizada para confirmar as compras no local"

		Requirement AssociarSenhaPulseirasFR(2.1.1) {
			text = "A senha criada deve ser associada a todas as pulseiras vinculadas a conta do cliente"
		}
	}
}

Requirement RetirarPulseiraFR(3.1) {
	text = "Os terminais possuem pulseiras equipadas com chip RFID e número identificador disponíveis para cada cliente"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement AssociarPulseiraFR(3.2) {
	text = "O cliente deve vincular uma pulseira a sua conta aproximando-a do leitor do terminal"
	satisfied by ArenaComponents.LeitorRFID1 ; derive AcessoSistemaFR.AcessoArenaFR;

	Requirement AssociarOutrasPulseiraFR(3.2.1) {
		text = "O cliente pode vincular outras pulseiras a sua conta"
	}
}

Requirement AdicionarSaldoFR(2.2) {
	text = "O cliente pode adicionar saldo à sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement TransferirSaldoFR(2.3) {
	text = "O cliente pode transferir saldo de sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement DesvincularPulseiraFR(2.4) {
	text = "O cliente pode desvincular uma pulseira a qualquer momento, em caso de perca"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement MultaPulseiraFR(2.4.1) {
		text = "O cliente deve pagar uma multa"
	}

	Requirement TravarSaldoFR(2.4.2) {
		text = "O saldo do cliente fica travado enquanto ele não pagar a multa"
	}
}

Requirement SaldoCompartilhadoFR(3.3) {
	text = "O saldo do cliente pode ser usado por todas as pulseiras cadastradas"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement DefinirLimitePulseiraFR(2.5) {
	text = "O cliente pode definir um limite de saldo para cada pulseira"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement RetirarPedidoFR(5.4) {
	text = "O cliente pode retirar os pedidos"
	derive AcessoSistemaFR.ComprarProdutosFR;

	Requirement RetirarProdutoMaquinaFR(5.4.1) {
		text = "O sistema deve permitir a retirada de itens prontos em máquinas automáticas mediante leitura do QR Code"
	satisfied by ArenaComponents.MaquinaAutomatica ; }

	Requirement ExibirStatusPedidoFR(5.4.2) {
		text = "O sistema deve exibir em telas no balcão o status do pedido (em produção ou pronto) e o número correspondente, para que o cliente entregue o comprovante e receba o produto"
		satisfied by ArenaComponents.PainelBalcaoEntrega;
	}

	Requirement RetirarPedidoBalcaoFR(5.4.3) {
		text = "O sistema deve permitir a retirada de itens preparados na hora em balcões de entrega mediante apresentação do número do pedido impresso"
		satisfied by ArenaComponents.ComputadorBalcao;
	}
}

Requirement QualidadeNFR(7) {
	text = "O sistema deve atender as necessidades de Desempenho, Disponibilidade e Confiabilidade, Segurança, Confiabilidade Operacional e Manutenibilidade e  Escalabilidade"

	Requirement DesempenhoNFR(8) {
		text = "O sistema deve suportar um grande volume de transações simultâneas durante o evento"
	}

	Requirement SegurancaNFR(9) {
		text = "O sistema deve garantir a segurança dos dados do cliente"
	}

	Requirement ConfiabilidadeNFR(10) {
		text = "O sistema deve ajudar a operacionar os registros e logs"
	}

	Requirement EscalabilidadeNFR(11) {
		text = "O sistema deve permitir adicionar mais terminais, totens e máquinas de retirada sem necessidade de grandes alterações"
	}
}

Requirement DadosNFR(9.1) {
	text = "Os dados pessoais e financeiros dos clientes devem ser armazenados de forma criptografada"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComunicacaoNFR(9.2) {
	text = "A comunicação entre dispositivos (totens, pulseiras, servidores e app) deve ser feita por canais seguros"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComprasNFR(9.3) {
	text = "O sistema deve impedir compras sem autenticação dupla (pulseira + senha de 4 dígitos)"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement TentativasNFR(9.4) {
	text = "O sistema deve bloquear automaticamente a pulseira após 3 tentativas incorretas de senha"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement DisponibilidadeNFR(10.1) {
	text = "O sistema deve estar disponível durante todo o período do evento, com tolerância mínima a falhas"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement MonitoramentoNFR(10.2) {
	text = "O sistema deve monitorar em tempo real o status de totens, máquinas de retirada e terminais"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement LogsNFR(10.3) {
	text = "O sistema deve registrar os logs de todas as operações (cadastro, compras, carregamento de crédito, devolução de pulseira)"
	derive QualidadeNFR.ConfiabilidadeNFR;
}