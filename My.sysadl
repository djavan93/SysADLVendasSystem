Model SysADLModel;

package SysADL.types {
	value type Int { }
	value type Boolean { }
	value type String { }
	value type Void { }
	value type Real { }

	enum StatusPedido {
		EM_PRODUCAO,
		PENDENTE,
		PRONTO,
		ENTREGUE
	}

	enum TipoProduto {
		PRONTO,
		PREPARADO
	}

	datatype ClienteDT {
		attributes :
			id : String;
			nome : String;
			senha : Int;
			saldoContra : Real;
	}

	datatype PulseiraDT {
		attributes :
			id : String;
			ativo : Boolean;
			cliente : ClienteDT;
	}

	datatype PedidoDT {
		attributes :
			id : String;
			itens : ItemPedidoDT;
			status : StatusPedido;
			qrCode : String;
			numeroOrdem : Int;
	}

	datatype ItemPedidoDT {
		attributes :
			quantidade : Int;
			produto : ProdutoDT;
	}

	datatype ProdutoDT {
		attributes :
			id : String;
			nome : String;
			preco : Real;
			tipo : TipoProduto;
	}

	datatype RecargaDT {
		attributes :
			Valor : Int;
			cliente : ClienteDT;
	}
datatype QRCodeDT { attributes : dados : String ; } datatype ProdutoRetiradoDT { attributes : produto : ProdutoDT ; quantidade : Int ; } value type DateTime { } datatype PulseiraDetectadaDT { attributes : Detectada : Boolean ; horario : DateTime ; } datatype DadosTelaDT { attributes : Dados : String ; } datatype PagamentoDT { attributes : dados : String ; cliente : ClienteDT ; } datatype RespostaPagamentoDT { attributes : pagamento : PagamentoDT ; confirmado : Boolean ; } datatype RespostaRecargaDT { attributes : recarga : RecargaDT ; confirmado : Boolean ; } datatype AtualizaSaldoDT { attributes : valor : Real ; cliente : ClienteDT ; } }

package ArenaConnectors {
	import ArenaPorts;

	connector def CnApiCliente {
		participants :
			~source : CadastroClienteOPT;
			~destination : CadastroClienteIPT;
		flows :
			ClienteDT from source to destination
	}

	connector def CnNotificacao {
		participants :
			~source : NotificacaoStatusOPT;
			~destination : NotificacaoStatusIPT;
		flows :
			StatusPedido from source to destination
	}

	connector def CnApiPedido {
		participants :
			~source : EnvioPedidoOPT;
			~destination : EnvioPedidoIPT;
		flows :
			PedidoDT from source to destination
	}

	connector def CnRecarga {
		participants :
			~destination : RecargaIPT;
			~source : RecargaOPT;
		flows :
			RecargaDT from source to destination
	}

	connector def CnPreparoPedido {
		participants :
			~source : PreparoPedidoOPT;
			~destination : PreparoPedidoIPT;
		flows :
			PedidoDT from source to destination
	}

	connector def CnPedidoConcluido {
		participants :
			~source : PedidoConcluidoOPT;
			~destination : PedidoConcluidoIPT;
		flows :
			PedidoDT from source to destination
	}
connector def CnDadosQRCode { participants : ~ source : DadosQRCodeOPT ; ~ destination : DadosQRCodeIPT ; flows : QRCodeDT from source to destination connector def newElement { } } connector def CnAtualizaQuantidade { participants : ~ source : ProdutoRetiradoOPT ; ~ destination : ProdutoRetiradoIPT ; flows : ProdutoRetiradoDT from source to destination } connector def CnPulseiraDetectada { participants : ~ source : PulseiraDetectadaOPT ; ~ destination : PulseiraDetectadaIPT ; flows : PulseiraDetectadaDT from source to destination } connector def CnImprimeQRCode { participants : ~ destination : DadosQRCodeIPT ; ~ source : DadosQRCodeOPT ; flows : QRCodeDT from source to destination } connector def CnDetectaPulseira { participants : ~ source : DetectaPulseiraOPT ; ~ destination : DetectaPulseiraIPT ; flows : PulseiraDT from source to destination } connector def CnInteracaoTela { participants : ~ source : InteracaoTela1IOPT ; ~ destination : InteracaoTela2IOPT ; flows : DadosTelaDT from source to destination DadosTelaDT from destination to source } connector def CnPagamento { participants : ~ source : RealizaPagamentoOPT ; ~ destination : RealizaPagamentoIPT ; flows : PagamentoDT from source to destination } connector def CnConfirmaPagamento { participants : ~ source : ConfirmaPagamentoOPT ; ~ destination : ConfirmaPagamentoIPT ; flows : RespostaPagamentoDT from source to destination } connector def CnConfirmaRecarga { participants : ~ source : ConfirmaRecargaOPT ; ~ destination : ConfirmaRecargaIPT ; flows : RespostaRecargaDT from source to destination } connector def CnAtualizaSaldo { participants : ~ source : AtualizaSaldoOPT ; ~ destination : AtualizaSaldoIPT ; flows : AtualizaSaldoDT from source to destination } }

package ArenaComponents {
	import SysADL.types;
	import ArenaConnectors;
	import ArenaPorts;

	 boundary

	component def TotemCompra {
		ports :
			PT_S_18 : EnvioPedidoOPT;
			
	PT_S_15 : DadosQRCodeOPT ; PT_D_14 : DetectaPulseiraIPT ; PT_D_16 : ConfirmaPagamentoIPT ; PT_S_17 : RealizaPagamentoOPT ; configuration { components :   ImpressoraQRCode : ImpressoraQRCode { using ports : PT_D_15 : DadosQRCodeIPT ; } LeitorRFID2 : LeitorRFID2 { using ports : PT_S_14 : DetectaPulseiraOPT ; } delegations :   PT_S_14 to PT_D_14 PT_D_15 to PT_S_15 } }

	component def ArenaPaySystem { ports : PT_D_6 : RecargaIPT ; PT_S_16 : ConfirmaPagamentoOPT ; PT_D_17 : RealizaPagamentoIPT ; PT_S_7 : ConfirmaRecargaOPT ; PT_S_19 : AtualizaSaldoOPT ; } boundary

	component def AplicativoCliente {
		ports :
			PT_S_13 : RecargaOPT;
	PT_D_12 : ConfirmaRecargaIPT ; }

	 boundary

	component def MaquinaAutomatica { ports : PT_D_1 : DadosQRCodeIPT ; PT_S_2 : ProdutoRetiradoOPT ; configuration { components :  LeitorQRCode : LeitorQRCode { using ports : PT_S_1 : DadosQRCodeOPT ; } delegations :  PT_S_1 to PT_D_1 } } boundary

	component def PainelBalcaoEntrega {
		ports :
			PT_D_9 : NotificacaoStatusIPT;
	}
	component def ComputadorBalcao {
		ports :
			PT_S_11 : PedidoConcluidoOPT;
			PT_D_10 : PreparoPedidoIPT;
	}

	component def TelaTouchScreen { ports : PT_SD1_3 : InteracaoTela1IOPT ; } boundary

	component def LeitorRFID1 { ports : PT_S_4 : DetectaPulseiraOPT ; }

	component def ARCH1 {
		
	configuration { components : Servidor : Servidor { using ports : PT_D_2 : ProdutoRetiradoIPT ; PT_D_5 : CadastroClienteIPT ; PT_S_9 : NotificacaoStatusOPT ; PT_S_10 : PreparoPedidoOPT ; PT_D_11 : PedidoConcluidoIPT ; PT_D_18 : EnvioPedidoIPT ; PT_D_19 : AtualizaSaldoIPT ; } PainelBalcaoEntrega : PainelBalcaoEntrega { using ports : PT_D_9 : NotificacaoStatusIPT ; } ComputadorBalcao : ComputadorBalcao { using ports : PT_S_11 : PedidoConcluidoOPT ; PT_D_10 : PreparoPedidoIPT ; } MaquinaAutomatica : MaquinaAutomatica { using ports : PT_D_1 : DadosQRCodeIPT ; PT_S_2 : ProdutoRetiradoOPT ; } LeitorQRCode : LeitorQRCode { using ports : PT_S_1 : DadosQRCodeOPT ; } ArenaPaySystem : ArenaPaySystem { using ports : PT_D_6 : RecargaIPT ; PT_S_16 : ConfirmaPagamentoOPT ; PT_D_17 : RealizaPagamentoIPT ; PT_S_7 : ConfirmaRecargaOPT ; PT_S_19 : AtualizaSaldoOPT ; } AplicativoCliente : AplicativoCliente { using ports : PT_S_13 : RecargaOPT ; PT_D_12 : ConfirmaRecargaIPT ; } TerminalAutoatendimento : TerminalAutoatendimento { using ports : PT_SD2_3 : InteracaoTela2IOPT ; PT_S_5 : CadastroClienteOPT ; PT_S_6 : RecargaOPT ; PT_D_7 : ConfirmaRecargaIPT ; PT_D_4 : DetectaPulseiraIPT ; } TelaTouchScreen : TelaTouchScreen { using ports : PT_SD1_3 : InteracaoTela1IOPT ; } LeitorRFID1 : LeitorRFID1 { using ports : PT_S_4 : DetectaPulseiraOPT ; } TotemCompra : TotemCompra { using ports : PT_S_18 : EnvioPedidoOPT ; PT_S_15 : DadosQRCodeOPT ; PT_D_14 : DetectaPulseiraIPT ; PT_D_16 : ConfirmaPagamentoIPT ; PT_S_17 : RealizaPagamentoOPT ; } ImpressoraQRCode : ImpressoraQRCode { using ports : PT_D_15 : DadosQRCodeIPT ; } LeitorRFID2 : LeitorRFID2 { using ports : PT_S_14 : DetectaPulseiraOPT ; } Catraca : Catraca { using ports : PT_D_8 : PulseiraDetectadaIPT ; } Detector : Detector { using ports : PT_S_8 : PulseiraDetectadaOPT ; } connectors : Cn1 : CnNotificacao bindings PT_S_9 = PT_D_9 ; Cn2 : CnPreparoPedido bindings PT_S_10 = PT_D_10 ; Cn3 : CnPedidoConcluido bindings PT_S_11 = PT_D_11 ; Cn4 : CnDadosQRCode bindings PT_S_1 = PT_D_1 ; Cn5 : CnAtualizaQuantidade bindings PT_S_2 = PT_D_2 ; Cn6 : CnAtualizaSaldo bindings PT_S_19 = PT_D_19 ; Cn7 : CnConfirmaRecarga bindings PT_S_7 = PT_D_12 ; Cn8 : CnRecarga bindings PT_S_13 = PT_D_6 ; Cn9 : CnConfirmaRecarga bindings PT_S_7 = PT_D_7 ; Cn10 : CnRecarga bindings PT_S_6 = PT_D_6 ; Cn11 : CnApiCliente bindings PT_S_5 = PT_D_5 ; Cn12 : CnInteracaoTela bindings PT_SD1_3 = PT_SD2_3 ; Cn13 : CnDetectaPulseira bindings PT_S_4 = PT_D_4 ; Cn14 : CnApiPedido bindings PT_S_18 = PT_D_18 ; Cn15 : CnPagamento bindings PT_S_17 = PT_D_17 ; Cn16 : CnConfirmaPagamento bindings PT_S_16 = PT_D_16 ; Cn17 : CnDadosQRCode bindings PT_S_15 = PT_D_15 ; Cn18 : CnDetectaPulseira bindings PT_S_14 = PT_D_14 ; Cn19 : CnPulseiraDetectada bindings PT_S_8 = PT_D_8 ; } }

	activity def GerenciarCadastroClienteAC(novoCliente : ClienteDT) : (clienteValidado : ClienteDT, mensagemResposta : String) {
		body {
			actions :
				vccan : ValidarCadastroClienteAN {
					using pins :
						novoCliente : ClienteDT;
				}
				eccan : EnviarCadastroClienteAN {
					using pins :
						clienteValidado : ResultadoValidacaoCliente;
				}
				emen : EnviarMensagemErroAN {
					using pins :
						clienteValidado1 : ResultadoValidacaoCliente;
				}
			delegate novoCliente to novoCliente
			
			delegate clienteValidado to eccan
			delegate mensagemResposta to emen 
			
			flow from vccan to switch {
			    case true: clienteValidado
			}
		}
	}

	action def ValidarCadastroClienteAN(novoCliente : ClienteDT) : Boolean {
		constraint :
			post-condition ValidarCadastroClienteEQ
	delegate novoCliente to novoCliente delegate ValidarCadastroClienteAN to clienteEhValido }

	constraint ValidarCadastroClienteEQ(novoCliente : ClienteDT) : (clienteEhValido : Boolean) {
		equation = (novoCliente->nome != null) ? (novoCliente->senha != null && novoCliente->senha > 6) : false
	}

	action def EnviarCadastroClienteAN(clienteEhValido : Boolean) : ClienteDT {
		constraint :
			post-condition EnviarCadastroClienteEQ
	 	delegate cliente to cliente 
	 	delegate EnviarCadastroClienteAN to clienteValidado
	 }
	
	constraint EnviarCadastroClienteEQ(cliente : ResultadoValidacaoCliente) : (clienteValidado : Cliente) {
	}

	action def EnviarMensagemErroAN(clienteValidado : ResultadoValidacaoCliente) : String {
		constraint :
			post-condition EnviarMensagemErroEQ
	delegate clienteValidado to clienteValidado delegate EnviarMensagemErroAN to mensagemErro }

	constraint EnviarCadastroClienteEQ(clienteEhValido : Boolean) : (clienteValidado : ClienteDT) { }

	constraint EnviarMensagemRespostaEQ(clienteEhValido : Boolean) : (mensagemResposta : String) {
		equation = clienteEhValido ? "Cadastro concluído com sucesso." : "Os dados fornecidos não são válidos."
	}
boundary
	component def LeitorQRCode { ports : PT_S_1 : DadosQRCodeOPT ; }
	component def LeitorRFID2 { ports : PT_S_14 : DetectaPulseiraOPT ; } boundary
	component def ImpressoraQRCode { ports : PT_D_15 : DadosQRCodeIPT ; } boundary
	component def Catraca { ports : PT_D_8 : PulseiraDetectadaIPT ; configuration { components :  Detector : Detector { using ports : PT_S_8 : PulseiraDetectadaOPT ; } delegations :  PT_S_8 to PT_D_8 } } boundary
	component def Detector { ports : PT_S_8 : PulseiraDetectadaOPT ; } component def TerminalAutoatendimento { ports : PT_SD2_3 : InteracaoTela2IOPT ; PT_S_5 : CadastroClienteOPT ; PT_S_6 : RecargaOPT ; PT_D_7 : ConfirmaRecargaIPT ; PT_D_4 : DetectaPulseiraIPT ; configuration { components : TelaTouchScreen : TelaTouchScreen { using ports : PT_SD1_3 : InteracaoTela1IOPT ; } LeitorRFID1 : LeitorRFID1 { using ports : PT_S_4 : DetectaPulseiraOPT ; } delegations : PT_SD1_3 to PT_SD2_3 PT_S_4 to PT_D_4 } }
	component def Servidor { ports : PT_D_2 : ProdutoRetiradoIPT ; PT_D_5 : CadastroClienteIPT ; PT_S_9 : NotificacaoStatusOPT ; PT_S_10 : PreparoPedidoOPT ; PT_D_11 : PedidoConcluidoIPT ; PT_D_18 : EnvioPedidoIPT ; PT_D_19 : AtualizaSaldoIPT ; configuration { components : ArenaPaySystem : ArenaPaySystem { using ports : PT_D_6 : RecargaIPT ; PT_S_16 : ConfirmaPagamentoOPT ; PT_D_17 : RealizaPagamentoIPT ; PT_S_7 : ConfirmaRecargaOPT ; PT_S_19 : AtualizaSaldoOPT ; } delegations : PT_S_19 to PT_D_19 } } }

package ArenaPorts {
	import SysADL.types;
	port def NotificacaoStatusOPT {
		flow out StatusPedido
	}

	port def NotificacaoStatusIPT {
		flow in StatusPedido
	}

	port def CadastroClienteIPT {
		flow in ClienteDT
	}

	port def CadastroClienteOPT {
		flow out ClienteDT
	}

	port def EnvioPedidoOPT {
		flow out PedidoDT
	}

	port def EnvioPedidoIPT {
		flow in PedidoDT
	}

	

	

	port def RecargaIPT {
		flow in RecargaDT
	}

	port def RecargaOPT {
		flow out RecargaDT
	}

	port def PreparoPedidoIPT {
		flow in PedidoDT
	}

	port def PreparoPedidoOPT {
		flow out PedidoDT
	}

	port def PedidoConcluidoIPT {
		flow in PedidoDT
	}

	port def PedidoConcluidoOPT {
		flow out PedidoDT
	}
port def DadosQRCodeIPT { flow in QRCodeDT } port def DadosQRCodeOPT { flow out QRCodeDT } port def ProdutoRetiradoIPT { flow in ProdutoRetiradoDT } port def ProdutoRetiradoOPT { flow out ProdutoRetiradoDT } port def PulseiraDetectadaIPT { flow in PulseiraDetectadaDT } port def PulseiraDetectadaOPT { flow out PulseiraDetectadaDT } port def DetectaPulseiraOPT { flow out PulseiraDT } port def DetectaPulseiraIPT { flow in PulseiraDT } port def InteracaoTela1IOPT { flow inout DadosTelaDT } port def InteracaoTela2IOPT { flow inout DadosTelaDT } port def RealizaPagamentoOPT { flow out PagamentoDT } port def RealizaPagamentoIPT { flow in PagamentoDT } port def ConfirmaPagamentoOPT { flow out RespostaPagamentoDT } port def ConfirmaPagamentoIPT { flow in RespostaPagamentoDT } port def ConfirmaRecargaOPT { flow out RespostaRecargaDT } port def ConfirmaRecargaIPT { flow in RespostaRecargaDT } port def AtualizaSaldoOPT { flow out AtualizaSaldoDT } port def AtualizaSaldoIPT { flow in AtualizaSaldoDT } }

Requirement AcessoSistemaFR(1) {
	text = "O sistema deve permitir o acesso de clientes"
	Requirement AcessoSiteAplicaticoFR(2) {
		text = "O site e o aplicativo devem estar sempre disponíveis para os usuários"
		satisfied by ArenaComponents.AplicativoCliente;
	}

	Requirement AcessoArenaFR(3) {
		text = "Ao entrar na arena, o cliente deve retirar uma pulseira para realizar compras no local"
	satisfied by SysADL.types.PulseiraDT ; }

	Requirement RecarregarCreditosFR(4) {
		text = "O sistema deve permitir a recarga de créditos através do site/aplicativo e dos terminais de autoatendimento" satisfied by ArenaComponents.ArenaPaySystem ;

		Requirement MeioPagamentoFR(4.1) {
			text = "O sistema deve permitir a recarga através de cartão de crédito/débito e pix"
		}
	}

	Requirement ComprarProdutosFR(5) {
		text = "O cliente pode realizar compras nos totens de autoatendimento" satisfied by ArenaComponents.TotemCompra , ArenaComponents.ArenaPaySystem ;

		Requirement SelecionarItensFR(5.1) {
			text = "O sistema deve permitir que o cliente selecione itens nos totens de autoatendimento"
		satisfied by ArenaComponents.TelaTouchScreen ; }

		Requirement ConfirmarCompraFR(5.2) {
			text = "O sistema deve exigir que a compra seja confirmada aproximando a pulseira no sensor" satisfied by ArenaComponents.LeitorRFID1 ;

			Requirement ConfirmarPagamentoFR(5.2.1) {
				text = "O cliente deve confirmar a compra digitando a senha de 4 dígitos"
			}
		}

		Requirement GerarComprovanteFR(5.3) {
			text = "O sistema deve gerar um comprovante impresso com QR Code ou/e número de ordem de pedido para cada compra"
		satisfied by ArenaComponents.ImpressoraQRCode ; }
	}

	Requirement SairArenaFR(6) {
		text = "O cliente deve passar pela catraca ao deixar a arena" satisfied by ArenaComponents.Catraca ;

		Requirement DevolverPulseiraFR(6.1) {
			text = "O sistema deve disponibilizar pontos de coleta da pulseira na saída"
		}

		Requirement EmitirAlertaPortaFR(6.2) {
			text = "O sistema deve emitir alertas nos detectores das portas caso alguém tente sair com a pulseira"
		}
	}
}

Requirement CadastroClienteFR(2.1) {
	text = "O sistema deve permitir o cadastro de clientes pelo site/aplicativo ou nos terminais de autoatendimento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement CriarSenhaFR(2.1) {
		text = "O cliente deve definir uma senha de 4 dígitos que será utilizada para confirmar as compras no local"

		Requirement AssociarSenhaPulseirasFR(2.1.1) {
			text = "A senha criada deve ser associada a todas as pulseiras vinculadas a conta do cliente"
		}
	}
}

Requirement RetirarPulseiraFR(3.1) {
	text = "Os terminais possuem pulseiras equipadas com chip RFID e número identificador disponíveis para cada cliente"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement AssociarPulseiraFR(3.2) {
	text = "O cliente deve vincular uma pulseira a sua conta aproximando-a do leitor do terminal"
	satisfied by ArenaComponents.LeitorRFID1 ; derive AcessoSistemaFR.AcessoArenaFR;

	Requirement AssociarOutrasPulseiraFR(3.2.1) {
		text = "O cliente pode vincular outras pulseiras a sua conta"
	}
}

Requirement AdicionarSaldoFR(2.2) {
	text = "O cliente pode adicionar saldo à sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement TransferirSaldoFR(2.3) {
	text = "O cliente pode transferir saldo de sua conta a qualquer momento"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement DesvincularPulseiraFR(2.4) {
	text = "O cliente pode desvincular uma pulseira a qualquer momento, em caso de perca"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;

	Requirement MultaPulseiraFR(2.4.1) {
		text = "O cliente deve pagar uma multa"
	}

	Requirement TravarSaldoFR(2.4.2) {
		text = "O saldo do cliente fica travado enquanto ele não pagar a multa"
	}
}

Requirement SaldoCompartilhadoFR(3.3) {
	text = "O saldo do cliente pode ser usado por todas as pulseiras cadastradas"
	derive AcessoSistemaFR.AcessoArenaFR;
}

Requirement DefinirLimitePulseiraFR(2.5) {
	text = "O cliente pode definir um limite de saldo para cada pulseira"
	derive AcessoSistemaFR.AcessoSiteAplicaticoFR;
}

Requirement RetirarPedidoFR(5.4) {
	text = "O cliente pode retirar os pedidos"
	derive AcessoSistemaFR.ComprarProdutosFR;

	Requirement RetirarProdutoMaquinaFR(5.4.1) {
		text = "O sistema deve permitir a retirada de itens prontos em máquinas automáticas mediante leitura do QR Code"
	satisfied by ArenaComponents.MaquinaAutomatica ; }

	Requirement ExibirStatusPedidoFR(5.4.2) {
		text = "O sistema deve exibir em telas no balcão o status do pedido (em produção ou pronto) e o número correspondente, para que o cliente entregue o comprovante e receba o produto"
		satisfied by ArenaComponents.PainelBalcaoEntrega;
	}

	Requirement RetirarPedidoBalcaoFR(5.4.3) {
		text = "O sistema deve permitir a retirada de itens preparados na hora em balcões de entrega mediante apresentação do número do pedido impresso"
		satisfied by ArenaComponents.ComputadorBalcao;
	}
}

Requirement QualidadeNFR(7) {
	text = "O sistema deve atender as necessidades de Desempenho, Disponibilidade e Confiabilidade, Segurança, Confiabilidade Operacional e Manutenibilidade e  Escalabilidade"

	Requirement DesempenhoNFR(8) {
		text = "O sistema deve suportar um grande volume de transações simultâneas durante o evento"
	}

	Requirement SegurancaNFR(9) {
		text = "O sistema deve garantir a segurança dos dados do cliente"
	}

	Requirement ConfiabilidadeNFR(10) {
		text = "O sistema deve ajudar a operacionar os registros e logs"
	}

	Requirement EscalabilidadeNFR(11) {
		text = "O sistema deve permitir adicionar mais terminais, totens e máquinas de retirada sem necessidade de grandes alterações"
	}
}

Requirement DadosNFR(9.1) {
	text = "Os dados pessoais e financeiros dos clientes devem ser armazenados de forma criptografada"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComunicacaoNFR(9.2) {
	text = "A comunicação entre dispositivos (totens, pulseiras, servidores e app) deve ser feita por canais seguros"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement ComprasNFR(9.3) {
	text = "O sistema deve impedir compras sem autenticação dupla (pulseira + senha de 4 dígitos)"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement TentativasNFR(9.4) {
	text = "O sistema deve bloquear automaticamente a pulseira após 3 tentativas incorretas de senha"
	derive QualidadeNFR.SegurancaNFR;
}

Requirement DisponibilidadeNFR(10.1) {
	text = "O sistema deve estar disponível durante todo o período do evento, com tolerância mínima a falhas"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement MonitoramentoNFR(10.2) {
	text = "O sistema deve monitorar em tempo real o status de totens, máquinas de retirada e terminais"
	derive QualidadeNFR.ConfiabilidadeNFR;
}

Requirement LogsNFR(10.3) {
	text = "O sistema deve registrar os logs de todas as operações (cadastro, compras, carregamento de crédito, devolução de pulseira)"
	derive QualidadeNFR.ConfiabilidadeNFR;
}